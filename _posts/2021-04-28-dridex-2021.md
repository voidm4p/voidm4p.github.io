---
layout: post
title: üá™üá∏ Analysis of the trojan Dridex (2021)
author: voidm4p
date: 2021-04-28 09:00:00
categories:
- malware
tags:
- dridex
- windows
toc: true
---
# An√°lisis del troyano Dridex (2021) 
Dridex es un troyano que apareci√≥ por primera vez en 2014 como resultado de la evoluci√≥n del troyano Cridex que, a su vez, se basa en el c√≥digo fuente de la familia Zeus filtrado con anterioridad. Se encuentra activo desde entonces debido al constante desarrollo por parte de los actores que operan el c√≥digo y su complejidad en cuanto a dise√±o, con una arquitectura basada en capas de proxies que ocultan los servidores de mando y control (C2) reales que 
se encuentra detr√°s de √©stos.
 
En este art√≠culo se abordar√° el an√°lisis del loader principal del malware a partir de una muestra de abril de 2021 cuyo hash SHA256 es: 126d93e7ddca40c743fac22376d2c6e5a654a9b0e3abcf3b42c1885f7c34029b.

## Antecedentes 
El desarrollo del troyano se le atribuye al grupo cibercriminal ruso autodenominado como "Evil Corp", al cual se le reconoce por otros nombres como: ‚Äú"A505", "SectorJ04", "INDRIK SPIDER", "GRACEFUL SPIDER", "GOLD TAHOE" o "Dudear" y se estima que ha podido generar m√°s de 100 millones de d√≥lares de beneficio con sus actividades.
 
Maksim Yakubets y Igor Turashev son se√±alados por el departamento de justicia de Estados Unidos en diciembre de 2019 como desarrolladores del malware y, al primero, como l√≠der del grupo, ofreciendo una recompensa de hasta 5 millones de d√≥lares por cualquie r informaci√≥n que pueda derivar en sus detenciones. 
 
![Image 1](/assets/img/posts/dridex-2021/img01_01.jpg)

La principal funcionalidad de Dridex es robar claves de acceso a aplicaciones de banca online mediante t√©cnicas como la inyecci√≥n de scripts maliciosos cuando √©stas son visitadas por el usuario. Sin embargo, su alcance no se queda ah√≠, pues se trata de un malware modular e incluye otros m√≥dulos para realizar otras actividades fraudulentas como keylogger, VNC o proxy SOCKS, adem√°s de servir para la distribuci√≥n de otras familias y tipos de  malware como Pony, spammers o stealers de emails y ransomware.
 
Con respecto al ransomware, en agosto de 2017, se atribuye al mismo grupo el desarrollo de BitPaymer que es utilizado como segunda etapa en la infecci√≥n del troyano en algunos casos, aunque tambi√©n es distribuido mediante otras amenazas como Emotet o Ursnif. Posteriormente, en 2019, aparece un nuevo ransomware, DoppelPaymer, el cual se atribuye tambi√©n a alguno de los miembros del grupo debido a sus similitudes con el anterior.

## Unpacking 
El cargador principal de Dridex consiste en una librer√≠a (DLL) que, usualmente, se encuentra empaquetada con el fin de proteger el c√≥digo original del binario y evitar detecciones de sistemas antivirus. Una vez desempaquetada se obtiene la librer√≠a original cuyo hash SHA256 es: 89e8098dbe0d736bbd3f04b3836fabea19ca22ee01f79ae419e2c16e4a4cbe21 
 
Lo primero que puede destacar al analizar est√°ticamente la librer√≠a es la ausencia de las funciones esperadas en un troyano de sus caracter√≠sticas en la tabla de importaciones, as√≠ como de cadenas de caracteres relevantes. Ambas t√©cnicas de ofuscaci√≥n se describir√°n m√°s adelante. 

## Resoluci√≥n de API din√°mica y manejador de excepciones 
Los nombres de las librer√≠as y de las API que utiliza el binario se encuentran ofuscados. Dridex utiliza una t√©cnica conocida como "**Call API by hash**" que ha implementado del siguiente modo: contiene hardcodeados en el c√≥digo hashes tipo CRC32 y una clave XOR que utiliza para comparar con el resultado del c√°lculo de dicho hash y posterior operaci√≥n XOR tanto para los nombres de DLL como de API.

![Image 2](/assets/img/posts/dridex-2021/img02_02.png)

Se pueden encontrar dos funciones diferentes que resuelven direcciones. Una recibe con la instrucci√≥n "`push`" los par√°metros del hashes xoreados de la librer√≠a y de la API a resolver, mientras que la otra recibe la direcci√≥n de la DLL resuelta previamente en otra funci√≥n y el hash pero, en este caso, mediante la instrucci√≥n "`mov`". 

![Image 3](/assets/img/posts/dridex-2021/img03_03.png)

Inicialmente, resuelve tanto las librer√≠as ntdll como *kernel32*, que se encuentran cargadas y se obtienen mediante el PEB del programa. A partir de aqu√≠, el resto de librer√≠as son cargadas mediante un proceso que consiste en utilizar `GetSystemDirectoryW`/`GetSystemWow64DirectoryW` y la combinaci√≥n `FindFirstFileExW`/`FindNextFileW` para recorrer el directorio de Windows y cargar la DLL a buscar mediante `LdrLoadDLL`. 
 
![Image 4](/assets/img/posts/dridex-2021/img03_04.png)
 
En versiones previas de Dridex, el nombre de la DLL a cargar era transformado a may√∫sculas antes de calcular su CRC32. Sin embargo, en las √∫ltimas muestras analizadas son transformados a min√∫sculas en su lugar. 

![Image 5](/assets/img/posts/dridex-2021/img04_05.png)

Dridex incluye una peculiaridad adem√°s de la implementaci√≥n de Call API by Hash y es que, en lugar de llamar directamente a la direcci√≥n de la API obtenida utiliza un manejador de interrupciones que desv√≠a el flujo normal del programa. Tras observar deteni damente el desensamblado del c√≥digo de la librer√≠a, se pueden localizar una serie de excepciones que el propio programa lanza mediante la instrucci√≥n "`int 3`". Esta instrucci√≥n viene precedida siempre de una llamada a la funci√≥n de resoluci√≥n de API y, a co ntinuaci√≥n, contiene la 
instrucci√≥n "`retn`". 

![Image 6](/assets/img/posts/dridex-2021/img04_06.png)

El manejador de excepciones programado comprueba si el c√≥digo de excepci√≥n es la 
constante `EXCEPTION_BREAKPOINT` y modifica el valor del registro `ESP` de tal forma que la instrucci√≥n retn que se ejecuta al devolver el flujo del programa a la l√≠nea siguiente, hace que se llame a la API en cuesti√≥n que se ha resuelto previamente la funci√≥n propia similar a `GetProcAddress`.  

![Image 7](/assets/img/posts/dridex-2021/img05_07.jpg)

Por tanto, la combinaci√≥n "`int3; ret`" podr√≠a sustituirse por la instrucci√≥n "`call eax`" para recuperar el flujo normal del programa. 
 
![Image 8](/assets/img/posts/dridex-2021/img05_08.png)

## Cadenas de caracteres 
Las cadenas de caracteres utilizadas por Dridex se encuentran tambi√©n ofuscadas. La funci√≥n que se encarga de resolverlas toma tres par√°metros: un buffer de salida con el resultado, un puntero al buffer con las cadenas cifradas y un √≠ndice. La funci√≥n descifra el buffer mediante RC4 con una clave que se encuentra en los primeros 40 bytes (0x28) y en orden inverso. Tras esto, el √≠ndice selecciona la cadena a devolver. 

![Image 9](/assets/img/posts/dridex-2021/img06_09.png)
 
## Informaci√≥n del sistema 
La funcionalidad principal de este cargador es recopilar diferente tipo de informaci√≥n que identifique al equipo infectado y realizar una petici√≥n de registro a la botnet vinculada a la muestra a trav√©s de uno de los proxies configurados. Dentro del c√≥digo se puede encontrar una funci√≥n que se encarga de dicha recopilaci√≥n y la informaci√≥n es al macenada en una estructura global para ser utilizada en las operaciones posteriores. 
 
En primer lugar obtiene el n√∫mero de compilaci√≥n, la versi√≥n de Windows y el tipo de producto mediante la API `GetVersionExW`.  

![Image 10](/assets/img/posts/dridex-2021/img06_10.png)

A continuaci√≥n, obtiene la arquitectura del procesador mediante `IsWow64Process`.  

![Image 11](/assets/img/posts/dridex-2021/img06_11.png)

Tras esto, comprueba qu√© tipo de usuario ejecuta el binario mediante `GetTokenInformation` pas√°ndole el valor `TokenGroups` al par√°metro `TokenInformationClass`. 

![Image 12](/assets/img/posts/dridex-2021/img07_12.png)
 
De esta forma obtiene el SID con `AllocateAndInitializeSid` y lo compara con el de administrador local *(S-1-5-32-544)* con `EqualSid`. 

![Image 13](/assets/img/posts/dridex-2021/img07_13.png)

Comprueba mediante el valor `TokenElevation` si el proceso actual est√° siendo ejecutado con permisos elevados y mediante el valor `TokenIntegrityLevel` asigna un valor entre 1 y 7 al nivel de integridad. 

![Image 14](/assets/img/posts/dridex-2021/img08_14.png)

Adem√°s, obtiene el ID de sesi√≥n de Terminal Services asociado al proceso mediante el PEB. 

![Image 15](/assets/img/posts/dridex-2021/img08_15.jpg)

Por otra parte, Dridex comprueba la clave de registro "`SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System`" mediante `RegQueryValueExA` para consultar los valores `EnableLUA`, `ConsentPromptBehaviorAdmin`, `PromptOnSecureDesktop` y, en base a los valores obtenidos le asigna un nivel entre el 0 y el 5.

![Image 16](/assets/img/posts/dridex-2021/img09_16.png)

Finalmente, Dridex utiliza `GetSystemInfo` para obtener el n√∫mero de procesadores, tama√±o de p√°gina, direcci√≥n de aplicaci√≥n m√≠nima y m√°xima y granularidad en la reserva de memoria.

![Image 17](/assets/img/posts/dridex-2021/img09_17.png)

De esta forma, se obtiene una estructura que recoge toda la informaci√≥n: 

![Image 18](/assets/img/posts/dridex-2021/img09_18.png)

## Comunicaci√≥n de red 
Una vez realizado el proceso de inicializaci√≥n y obtenida la informaci√≥n necesaria, la finalidad principal del cargador de Dridex es registrar a la v√≠ctima en el panel C2 y descargar el m√≥dulo principal junto con el listado de nodos. 
 
Toda la comunicaci√≥n con los servidores C2 es cifrada mediante RC4 y encapsulada con el protocolo HTTPS. La funci√≥n que inicializa la petici√≥n al servidor recibe un par√°metro que se trata de un hash CRC32 que identifica el tipo de respuesta. 

![Image 19](/assets/img/posts/dridex-2021/img10_19.png)

El malware accede a la secci√≥n ".data" del binario y construye una estructura con el ID de la botnet y un listado de direcciones IP hardcodeadas.  

![Image 20](/assets/img/posts/dridex-2021/img10_20.png)

Los valores del binario analizado son: 

- ID de botnet: 40112 
- N√∫mero de IP: 3 
    - 107.172.227.10:443 
    - 172.93.133.123:2303 
    - 108.168.61.147:8172 

![Image 21](/assets/img/posts/dridex-2021/img11_21.png)

A continuaci√≥n, construye una estructura para formar la petici√≥n a partir de la informaci√≥n recopilada anteriormente. La estructura se compone de los siguientes campos: 

- **`len(victim_id)`**: longitud del victim_id 
- **`victim_id`**: nombre del equipo seguido del hash md5 del nombre del equipo + nombre de usuario + "\x00\x00\x00" + fecha de instalaci√≥n + "\x00\x00". La fecha de instalaci√≥n es obtenida de la clave de registro "`HKLM \Software\Microsoft\Windows 
NT\CurrentVersion\InstallDate`". 
- **`system_id_hash`**: hash md5 del serial del disco + fecha de instalaci√≥n + x64_or_x32 + "\x00\x00". 
- **`botnet_id`**: el ID de la botnet 
- **`sys_info`**: estructura calculada con informaci√≥n como el Windows Build Number, productType, arquitectura, el flag UAC y si tiene permisos de administrador as√≠ como un byte que indica la versi√≥n de windows mediante el c√°lculo `((majorversion << 4 - 80) + minorversion)` 

![Image 22](/assets/img/posts/dridex-2021/img12_22.png)

- **`command`**: c√≥digo crc32 del comando a enviar: 
    - bot == 0x11041f01 
    - list == 0x18f8c844 
    - dmod5 == 0xd3ef7577 
    - dmod6 == 0x69be7cee 
    - dmod11 == 0x32dc1df8
- **`x64_or_x32`**: un byte con 32 (0x20) o 64 (0x40) en funci√≥n de la arquitectura. 
- **`len(installed_software)`**: longitud deinstalled_software 
- **`installed_software`**: listado de software instalado en el equipo obtenido de la clave de registro `HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall` 
- **`len(envs)`**: longitud de envs 
- **`envs`**: cadena que contiene las variables de entorno obtenidas con la API `GetEnvironmentStringsW`. 

![Image 23](/assets/img/posts/dridex-2021/img12_23.png)

Una vez construida la estructura para la petici√≥n, √©sta es cifrada utilizando RC4 con una clave que se encuentra almacenada entre las cadenas de caracteres cifradas del binario. La clave RC4 de la muestra analizada es: `AhGDjKatq8OVBsCNBxsJHbQSf84QZXMd170Lw0k`.  
 
La petici√≥n final se forma mediante el hash CRC32 del contenido una vez cifrado seguido del propio contenido cifrado. 
 
El paquete es enviado mediante el m√©todo POST utilizando la librer√≠a WinINet mediante `InternetOpenA`, `InternetConnectW`, `HttpOpenRequestW` y `HttpSendRequestW`. 
 
La respuesta del servidor es le√≠da mediante InternetReadFile y, si el c√≥digo de respuesta es 200 o 404, el contenido es descifrado utilizando RC4 con la misma clave que cifr√≥ la petici√≥n enviada. Esta respuesta siempre comienza con un hash CRC32 del conten ido seguido del propio contenido.

![Image 24](/assets/img/posts/dridex-2021/img13_24.png)
 
Una vez llegado a este punto, en funci√≥n de diferentes factores, como la localizaci√≥n del punto de acceso a internet, el listado de software instalado y variables de entorno, el nombre de usuario de la v√≠ctima o la antig√ºedad del binario, los servidores responder√°n favorablemente o, por el contrario, con un c√≥digo `403 FORBIDDEN`, quedando adem√°s baneado para futuras 
peticiones. 

Este hecho dificulta enormemente poder contactar y recibir informaci√≥n de los servidores C2 desde un entorno de an√°lisis, ya que no se pueden asegurar a ciencia cierta cuales son los par√°metros que espera o no recibir la botnet. 
 
Los intentos de conexi√≥n desde la m√°quina de an√°lisis obtienen siempre un c√≥digo 403, incluso con muestras recientes. 

![Image 25](/assets/img/posts/dridex-2021/img14_25.png)


## Emulador 
Si se desea analizar la comunicaci√≥n con los servidores y poder proseguir con el an√°lisis es necesario tratar de recrear el paquete de la petici√≥n mediante la informaci√≥n averiguada durante el proceso de ingenier√≠a inversa y tener as√≠ un sistema para alter ar los par√°metros libremente en caso de que se detecten posibles baneos.  
 
En primer lugar, se crea una clase con las variables necesarias. 

![Image 26](/assets/img/posts/dridex-2021/img14_26.png)

A continuaci√≥n, se reimplementan los algoritmos que permiten generar la petici√≥n. 

![Image 27](/assets/img/posts/dridex-2021/img15_27.png)
 
Y, por √∫ltimo, el cifrado y env√≠o de la petici√≥n. 
 
![Image 28](/assets/img/posts/dridex-2021/img15_28.png)

Como se puede observar, la mayor√≠a de las variables que dependen de la m√°quina son asignadas de forma aleatoria para evitar baneos basados en estos par√°metros. Adem√°s, se han probado multitud de variaciones en el listado de software instalado y variables de entorno.

Por otra parte, se ha tratado de realizar conexiones desde diferentes localizaciones como Estados Unidos, Francia, Italia, Alemania, Rusia, Colombia, M√©xico o Espa√±a a trav√©s de una conexi√≥n VPN, as√≠ como con direcciones de proxy y claves RC4 de muestras lo m√°s recientes posibles.  
 
![Image 29](/assets/img/posts/dridex-2021/img16_29.jpg)
![Image 30](/assets/img/posts/dridex-2021/img16_30.jpg)

 
Por tanto, llegado a este punto, no se puede proseguir con el an√°lisis de las conexiones del loader con el servidor C2. No obstante, s√≠ que se pueden detectar algunos comportamientos esperados a trav√©s de la ingenier√≠a inversa del loader de forma est√°tica.

## Comunicaci√≥n entre el loader y el bot 
Si el bot se descarga del C2 y comienza a ejecutarse, el loader necesita una forma de compartir la informaci√≥n obtenida del comando "list" con este. Para ello, el loader utiliza la clave de registro `Software\Microsoft\Windows\CurrentVersion\Explorer\CLSID\%s\shellfolder`, donde %s es un CLISD construido a partir del hash victim_id con el byte hardcodeado 0x1c. 

![Image 31](/assets/img/posts/dridex-2021/img17_31.png)

En dicha clave se guardar√° informaci√≥n como el ID de la botnet, el tama√±o de la lista de nodos, el listado de nodos y una URI utilizada posteriormente para crear una tarea programada que asegure la persistencia del bot.

## Persistencia 
Dridex copia un programa desde el directorio de Windows a un nuevo directorio 
en %AppData% con un nombre aleatorio, donde la DLL del bot descargado es copiada y renombrada como una de las librer√≠as que carga el binario copiado. Tras esto, se crea una tarea programada que lanza el binario leg√≠timo y la DLL es hijacked por la de Dridex. 
 
Para ello, el loader escanea todos los ficheros .exe que se encuentren en el directorio de Windows y selecciona uno que no tenga la propiedad "AutoElevated". A continuaci√≥n, enumera las librer√≠as importadas por el binario y comprueba si el nombre de alguna  de ellas concuerda con una lista blanca de hashes CRC32. 

![Image 32](/assets/img/posts/dridex-2021/img18_32.png)

Cuando la DLL es seleccionada, el loader obtiene el listado de funciones exportadas por dicha librer√≠a y lo copia a la DLL del core de Dridex. Finalmente, la librer√≠a es copiada al nuevo directorio aleatorio en %APPDATA% con el nombre de la librer√≠a leg√≠tima. 

![Image 33](/assets/img/posts/dridex-2021/img19_33.png)
 
Una vez el binario ha sido copiado y, en funci√≥n del nivel de privilegio con que se haya ejecutado el loader, Dridex crea una o dos tareas programadas mediante objetos COM. Si el binario obtiene permisos de administrador, se generan dos tareas programadas con una URI aleatoria dentro de dentro de la ruta `\Tasks\Microsoft\Windows` del directorio de instalaci√≥n de Windows. 

![Image 34](/assets/img/posts/dridex-2021/img19_34.png)

La diferencia entre ambas tareas reside en el nombre de la URI. La primera toma un fichero de tarea leg√≠tima y le a√±ade el SID del usuario. El comando ejecutado es el binario leg√≠timo copiado al directorio de instalaci√≥n en `%APPDATA%`. 
 
Para la segunda, el comienzo de la URI es seleccionado de forma aleatoria y el nombre de fichero es construido con un algoritmo pseudo aleatorio basado en el hash previo `victim_id` donde genera hashes md5 y selecciona los caracteres ASCII hasta construir un a cadena de longitud 0x30. El comando ejecutado es un directorio aleatorio dentro del directorio de Windows, por lo que si no existe, no se ejecutar√° nada as√≠ que no queda del todo claro el uso de esta tarea. 
 
Para registrarlas se utilizan objetos COM mediante la llamada a la API `CoCreateInstance`.

![Image 35](/assets/img/posts/dridex-2021/img20_35.png)

Ambas tareas son lanzadas al iniciar sesi√≥n y cada 30 minutos. Las diferencias entre la versi√≥n con privilegios y sin ellos son que el path de la URI de la tarea se encuentra en la carpeta ra√≠z y el nombre es generado con la funci√≥n pseudoaleatoria.

## Mutex 
Antes y despu√©s de registrar la tarea programada, el loader comprueba la presencia de un Mutex. Si existe, quiere decir que la DLL del bot ha sido ejecutada por la tarea programada de forma correcta y se encuentra inyectada en el proceso explorer.exe. En caso de no existir este, intenta volver a lanzar la tarea. 
 
![Image 36](/assets/img/posts/dridex-2021/img21_36.png)

El nombre del mutex es calculado mediante hash md5 de forma similar a identificadores anteriores. En este caso, los datos son computer_name + username + ‚Äú \x00\x02\x00‚Äù + installDate + ‚Äú\x00\x00‚Äù y es formateado como un CLSID.

## Referencias 
- https://malpedia.caad.fkie.fraunhofer.de/details/win.dridex 
- https://www.appgate.com/blog/reverse-engineering-dridex-and-automating-ioc-extraction 
- https://www.appgate.com/blog/breaking-dridex-and-creating-a-vaccine 
- https://securelist.com/dridex-a-history-of-evolution/78531/ 
- https://securitynews.sonicwall.com/xmlpost/dridex-malware-evading-detection-using-delaying-techniques/ 
- https://www.cronup.com/post/de-ataque-con-malware-a-incidente-de-ransomware 
- https://www.cert.ssi.gouv.fr/uploads/CERTFR-2020-CTI-008.pdf 
- https://countuponsecurity.com/tag/dridex-rc4/ 
- https://www.pandasecurity.com/es/mediacenter/pandalabs/dridex-version-4/ 
- https://www.blueliv.com/downloads/documentation/reports/Network_insights_of_Dyre_and_Dridex_Trojan_bankers.pdf 
- https://www.fortinet.com/blog/threat-research/hundreds-of-urls-inside-microsoft-excel-spreads-new-dridex-trojan-variant 
- https://countuponsecurity.com/tag/dridex-malware-analysis/ 
- https://www.forcepoint.com/es/blog/x-labs/dridex-shadows-blacklisting-stealth-and-crypto-currency 
- https://blog.lexfo.fr/dridex-malware.html 

## Anexo: IDA Script para resolver las direcciones de la API 
Para IDA 7.5 con python3. Basado en el trabajo de AppGate. 
 
```python
import idautils 
import pefile 
import zlib 
import os 
 
# ---------------------- Functions ---------------------- # 
def get_path_dirs(): 
    return [x for x in os.path.expandvars("%PATH%").split(";") if x] 
 
def generate_hashes_table(key): 
    hashes = [] 
    for path_dir in get_path_dirs(): 
        for dll_name in os.listdir(path_dir): 
            dll_hash =  crc32(dll_name.lower()) # upper previously, change if needed 
            dll_dict = {'name': dll_name, 'hash': dll_hash, 'imports': []} 
            hashes.append(dll_dict) 
    return hashes 
 
def crc32(value): 
    r = hex(zlib.crc32(value.encode('utf-8')) & 0xffffffff)  # Positive integer 
    if r[-1] == "L": 
        r = r[:-1]  # Get rid of python L for Long 
    return r 
 
def get_dridex_hash(s, dll, key): 
    return hex(((zlib.crc32(s.lower().encode() if dll else s.encode()) & 0xffffffff) ^ key)) 
 
def api_resolver(dll_hash, api_hash, hashes): 
    for item in hashes: 
        if dll_hash != item['hash']: 
            continue 
        print(item['name'], dll_hash, item['hash']) 
        if not item['imports']: 
            for path_dir in get_path_dirs(): 
                if not os.path.exists(os.path.join(path_dir, item["name"])): 
                    continue 
                pe = pefile.PE(os.path.join(path_dir, item["name"])) 
                exp_list = [] 
                for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols: 
                    try: 
                        exp_list.append(exp.name.decode('utf-8')) 
                    except: 
                        continue 
                for import_name in exp_list: 
                    _hash = crc32(import_name) 
                    item['imports'].append({'name': import_name, 'hash': _hash}) 
        for api in item['imports']: 
            if api_hash == api['hash']: 
                return "{}!{}".format(item['name'], api['name']) 
        return "{}!unknown".format(item['name']) 
 
def resolve_apis(resolver_offset, hashes_table, xor_key): 
    for xref in idautils.XrefsTo(resolver_offset): 
        off = idc.prev_head(xref.frm) 
        # This loop will search for the hash that is being passed by the function 
        # It's limited to 100 searches to avoid possible infinite loops. 
        dll, api = None, None 
        for i in range(1, 101): 
            if i == 100: 
                print("[-] Cannot find hash for address: %s" % hex(xref.frm)) 
                break 
            # If it's not a "push" operation, keep looking 
            if idc.print_insn_mnem(off) != "push": 
                off = idc.prev_head(off) 
                continue 
            # If a "push" is identified, checks if it's the DLL or the API hash 
            if not dll: 
                value = hex(idc.get_operand_value(off, 0)) 
                dll = hex(int(value, 16) ^ xor_key) 
                if dll[-1] == "L": 
                        dll = dll[:-1] 
                off = idc.prev_head(off) 
                continue 
            value = hex(idc.get_operand_value(off, 0)) 
            api = hex(int(value, 16) ^ xor_key) 
            if api[-1] == "L": 
                api = api[:-1] 
            if api and dll: 
                break 
        if api and dll: 
            print(dll, api) 
            # If the DLL was already found, then the second push is the API hash 
            api_name = api_resolver(dll, api, hashes_table) 
            comment = "" if not api_name else api_name 
            idc.set_cmt(xref.frm, comment, True) 
 
def resolve_apis_v2(resolver_offset, hashes_table, xor_key): 
    for xref in idautils.XrefsTo(resolver_offset): 
        off = idc.prev_head(xref.frm) 
        # This loop will search for the hash that is being passed by the function 
        # It's limited to 100 searches to avoid possible infinite loops. 
        dll, api = None, None 
        for i in range(1, 21): 
            if i == 20: 
                print("[-] Cannot find hash for address: %s" % hex(xref.frm)) 
                break 
            # If it's not a "mov" operation, keep looking 
            if idc.print_insn_mnem(off) != "mov": 
                off = idc.prev_head(off) 
                continue 
            # If a "mov" is identified, it's the API hash 
            if not api: 
                value = idc.print_operand(off, 1) 
                if value[-1] == "h" and len(value) > 5: 
                    api = hex(int(value[:-1], 16) ^ xor_key) 
                    if api[-1] == "L": 
                        api = api[:-1] 
 
                off = idc.prev_head(off) 
                continue 
            # If the API hash was already found, then the second mov upwards is the DLL 
            else: 
                if not dll: 
                    value = idc.print_operand(off, 1) 
                    if value[-1] == "h" and len(value) > 5: 
                        dll = hex(int(value[:-1], 16) ^ xor_key) 
                        if dll[-1] == "L": 
                            dll = dll[:-1] 
                    off = idc.prev_head(off) 
            if api and dll: 
                break 
        if api and dll: 
            print("MOV", dll, api) 
            api_name = api_resolver(dll, api, hashes_table) 
            comment = "" if not api_name else api_name 
            idc.set_cmt(xref.frm, comment, True) 
 
def brute_force_xor(resolver_offset): 
    dlls_hashes = [] 
    for xref in idautils.XrefsTo(resolver_offset): 
        off = idc.prev_head(xref.frm) 
        dll, api = None, None 
        for i in range(1, 101): 
            if i == 100: 
                print("[-] Cannot find hash for address: %s" % hex(xref.frm)) 
                break 
            if idc.print_insn_mnem(off) != "push": 
                off = idc.prev_head(off) 
                continue 
            if not dll: 
                dll = idc.get_operand_value(off, 0) 
                off = idc.prev_head(off) 
                continue 
            api = idc.get_operand_value(off, 0) 
            if api and dll: 
                break 
        if api and dll: 
            dlls_hashes.append(dll) 

     
    kernel32_hash = int(crc32("kernel32.dll".lower()), 16) 
    oleaut_hash = int(crc32("oleaut32.dll".lower()), 16) 
    wininet_hash = int(crc32("wininet.dll".lower()), 16) 
    keys_1 = [] 
    keys_2 = [] 
    keys_3 = [] 
    for hardcoded_hash in dlls_hashes: 
        keys_1.append(hardcoded_hash ^ kernel32_hash) 
        keys_2.append(hardcoded_hash ^ oleaut_hash) 
        keys_3.append(hardcoded_hash ^ wininet_hash) 
 
    return list(set(keys_1).intersection(keys_2, keys_3)) 
 
def find_resolvers_func_candidates(): 
    funcs = Functions() 
    for f in funcs: 
        name = idc.get_name(f) 
        xrefs_count = len((list(idautils.XrefsTo(f)))) 
        if xrefs_count >= 55: 
            print("%s %d" % (name, xrefs_count)) 
# ---------------------- Main ---------------------- # 
xor_key = None 
def hashes_1(resolver_function): 
    global xor_key 
    if not xor_key: 
        xor_key = brute_force_xor(resolver_function)[0] 
    hashes = generate_hashes_table(xor_key) 
    resolve_apis(resolver_function, hashes, xor_key) 
 
def hashes_2(resolver_function): 
    global xor_key 
    if xor_key: 
        hashes = generate_hashes_table(xor_key) 
        resolve_apis_v2(resolver_function, hashes, xor_key) 
``` 
 
## Anexo: IDB 
[Enlace](/assets/other/dridex/dridex_unpacked.dll.idb) al fichero idb con el reversing del binario.