---
layout: post
title: üá™üá∏ Analysis of the communication protocol of Android trojan Xenomorph
author: voidm4p
date: 2022-04-03 09:00:00
categories:
- malware
tags:
- xenomorph
- android
toc: true
---
# An√°lisis del protocolo de comunicaci√≥n del troyano para Android Xenomorph 
 
En febrero de 2022, el fabricante ThreatFabric  se encontr√≥ con un nuevo troyano bancario para Android al que han llamado Xenomorph. El nombre proviene de sus claros v√≠nculos con otro troyano bancario llamado Alien del cual Xenomorph adopta algunas caracter√≠sticas como nombres de clases o cadenas de te xto, pese a tratarse de una implementaci√≥n independiente y no basada en √©ste. 
 
Seg√∫n <a href="https://www.threatfabric.com/blogs/xenomorph-a-newly-hatched-banking-trojan.html" target="_blank">el informe publicado</a>, este malware afectar√≠a a los usuarios de hasta 56 bancos europeos diferentes y habr√≠a sido encontrado siendo distribuido en la tienda oficial de Google Play con m√°s de 50.000 instalaciones. 
 
Este listado de aplicaciones a las que puede suplantar el malware es proporcionado por el servidor de mando y control (C2) que trae configurado la muestra. Sin embargo, un aspecto al que no entra muy en detalle el informe compartido por ThreatFabric es el protocolo espec√≠fico utilizado por la aplicaci√≥n para obtener este listado y que, mediante su estudio, permitir√≠a la automatizaci√≥n de √©ste con el objetivo de analizar futuras muestras o monitorizar cambios en los listados de aplicaciones afectadas por los C2 detectados. 
 
En este art√≠culo se analizar√° el protocolo de comunicaci√≥n de Xenomorph y se comprobar√° c√≥mo, gracias a √©sto, es posible implementar un Bot que emule las peticiones del troyano para interactuar con sus servidores C2. 
 
Este estudio se basa en la muestra de Xenomorph compartida por ThreatFabric que, tras ser descifrada, corresponde con el siguiente hash sha256: dae52bbee7f709fae9d91e06229c35b46d4559677f26152d4327fc1601d181be 
 
La muestra contiene una serie de constantes que son utilizadas para personalizar dicha muestra y que, podr√≠an variar entre unas y otras. La mayor parte de esta configuraci√≥n personalizada del malware se encuentra definida en un fichero llamado "Constants" donde se encuentran, entre otros, los dominios y direcciones de API de los C2, la clave de cifrado a utilizar o el tag del bot. 
 
![Image 1](/assets/img/posts/xenomorph-2022/Imagen 1.png)
 
El malware contiene dos rutas principales con las que interact√∫a: /ping y /metrics. La ruta concreta para estas peticiones est√° tambi√©n configurada en el fichero "Constants" por lo que puede variar entre unas muestras y otras. 
 
Con respecto a la comunicaci√≥n con el servidor, Xenomorph destaca frente a otros troyanos por la utilizaci√≥n del proyecto de c√≥digo abierto Retrofit2, un cliente REST para Android, Java y Kotlin desarrollado por la empresa Square y que se basa, a su vez, en OkHttp.   

Las peticiones al servidor son cifradas mediante el algoritmo de cifrado AES. Inicialmente, se utiliza una clave que es establecida en el c√≥digo, a lo que el servidor responde con una nueva clave utilizada para dicha sesi√≥n hasta que se realice otra petici√≥n que la reemplace por una nueva. 
 
## PETICI√ìN DE REGISTRO /ping 
 
La petici√≥n inicial a la ruta /ping se construye de la siguiente forma: 

```json
{ 
    "hash": "<hash de verificaci√≥n de los datos de registro>",  
    "id": "<datos de registro cifrados>", 
    "iv": "<vector de inicializaci√≥n AES utilizado para cifrar los datos>", 
    "type": "request_verify" 
} 
```
 
El valor del "`hash`" se calcula mediante la concatenaci√≥n en bytes de la clave de cifrado AES  configurada en el c√≥digo, la ruta donde se encuentra la petici√≥n inicial en el servidor y el IMEI del dispositivo. El siguiente c√≥digo python emula los datos utilizados para construir los datos para calcular dicho hash. A esta informaci√≥n se le calcula su SHA256 y se codifica mediante base64. 

```python
    def __ping_hash_bytes__(self): 
        bytes_1 = bytes.fromhex(self.aes_key_init) 
        bytes_2 = "{}/{}".format(self.active_c2, self.api_location_verify).encode("latin1") 
        bytes_3 = bytes.fromhex(self.imei) 
        return bytes_1 + bytes_2 + bytes_3 
```

En el campo "id" se env√≠a la informaci√≥n de registro cifrada con la clave AES establecida en el c√≥digo. En el caso de la muestra analizada, esta clave es 
"5f9e4a92b1d8c8b98db9b7f8f8800d2e". La estructura del campo "id" es la siguiente. 

```json
{ 
    "api": "<N√∫mero del SDK del dispositivo>", 
    "apps": ["<listado de aplicaciones instaladas>"], 
    "imei": "<IMEI>", 
    "model": "<modelo de dispositivo>", 
    "numbers":["<listado de contactos>"], 
    "tag": "<tag del bot configurado>", 
    "uid": "<IMEI>"
} 
```

Tras esto, se env√≠a la petici√≥n de registro a la que el servidor da una respuesta. 

## RESPUESTA DE REGISTRO /ping 
El servidor responde a esta petici√≥n con una estructura similar a la enviada donde el campo "id" contiene ahora la nueva clave de cifrado AES que se utilizar√° en las peticiones posteriores. Este dato viene cifrado igualmente con AES utilizando la clave inicial y, como vector de inicializaci√≥n IV, el que viene en la respuesta recibida. Este es un eje mplo de respuesta para la petici√≥n /ping. 

```json
{ 
    "type":"reponse_verify", 
    "hash":"ON9Kk2P+wes7KgQFxJZzVMkZflh1o32k5YnFZP97ljY=", 
    "iv":"/FIWarzQ200j1dAD9jwC0A==", 
    "id":"BeUatLhbxruLSs/GMzWCvqVSIAKlNfmvBzPo7LrzPr8=" 
} 
```

Donde el campo "id" se descifra del siguiente modo. 
 
![Image 2](/assets/img/posts/xenomorph-2022/Imagen 2.png)
 
Tras esto, el bot queda registrado y puede realizar peticiones al servidor mediante el m√©todo /metrics. 
 
## PETICI√ìN DE OPERACIONES /metrics 
 
Estas peticiones tienen la siguiente estructura: 
```json
{ 
    "hash": "<hash de verificaci√≥n de la petici√≥n metrics>", 
    "id": "<base64 del sha256 del IMEI>", 
    "iv": "<vector IV utilizado para cifrar la petici√≥n>", 
    "metrics": "<informaci√≥n solicitada o petici√≥n de comandos cifrada con AES y la clave de sesi√≥n obtenida del servidor>" 
} 
```

El campo "id" se calcula mediante el hash SHA256 del IMEI del dispositivo codificado en base64. El siguiente c√≥digo python emula dicho c√°lculo:

```python
b64encode(hashlib.sha256(bytes.fromhex(self.imei)).digest()).decode("latin1") 
```

El campo "hash" es ahora calculado mediante una concatenaci√≥n de bytes diferente, 
uniendo la clave AES inicial, la nueva clave AES y el vector de inicializaci√≥n IV utilizado para cifrar los datos de la petici√≥n a enviar. El siguiente c√≥digo python emula dicha concatenaci√≥n. Al igual que antes, a estos bytes se calcula su hash SHA256 y se codifican en base64.  

```python
    def __metrics_hash_bytes__(self, iv): 
        bytes_1 = bytes.fromhex(self.aes_key_init) 
        bytes_2 = bytes.fromhex(self.metrics_aes_key) 

        bytes_3 = iv 
        return bytes_1 + bytes_2 + bytes_3 
```

Mediante la ruta /metrics el bot env√≠a una petici√≥n peri√≥dica para consultar si tiene comandos por ejecutar o, si ha recibido una orden de ejecuci√≥n, la informaci√≥n solicitada por alguno de los comandos. Para realizar esta petici√≥n se utiliza el campo "metrics" con la siguiente estructura que es cifrada mediante la nueva clave AES y un vector IV aleatorio. 

```json
{ 
    "permissions":["notification_manager","generic_permissions"], 
    "rm_triggered":false, 
    "user_present":true, 
    "type":"get_coms" 
} 
```
 
 
## RESPUESTAS DE OPERACIONES /metrics 
 
A esta petici√≥n peri√≥dica de comandos, el servidor responde con la siguiente estructura:

```json
{ 
    "metrics": "<respuesta cifrada>", 
    "hash": "<hash de verificaci√≥n>", 
    "iv": "<IV utilizado en el cifrado AES>", 
    "id": "<id enviado en la petici√≥n anterior>" 
} 
```

El contenido de "metrics" es descifrado y contiene el siguiente diccionario: 
```json
{ 
    "type": "get_coms",  
    "coms": [] 
} 
```

El campo "coms" trae un listado con los posibles comandos a ejecutar o un array vac√≠o, en caso de que no haya nada que ejecutar. Los diferentes comandos que pueden recibirse del C2 son los siguientes. 
 
- `sms_log` 
- `self_kill` 
- `notif_ic_disable` 
- `fg_disable` 
- `inj_list` 
- `notif_ic_enable` 
- `self_cleanup` 
- `notif_ic_update` 
- `sms_ic_disable` 
- `fg_enable` 
- `inj_enable` 
- `app_kill` 
- `app_list` 
- `sms_ic_enable` 
- `inj_update` 
- `inj_disable` 
- `sms_ic_update` 
- `sms_ic_list` 
- `notif_ic_list` 
 
## EL COMANDO `inj_update`
 
Mediante el comando ‚Äú`inj_update`‚Äù es posible recuperar el listado completo de aplicaciones de las que contiene inyecciones el C2. Para ello, mediante la misma ruta de operaciones /metrics se env√≠a un comando en el que en el campo ‚Äúmetrics‚Äù se env√≠a cifrado el siguiente diccionario. 

```json
{ 
    "type": "inj_update" 
} 
```

A esto el servidor responde, tras descifrar su respuesta, con un listado de identificadores de apps y la URL desde la que descargar su inyecci√≥n correspondiente. A continuaci√≥n se puede observar el flujo completo de peticiones y respuestas descifradas que han sido emuladas para poder obtener dicho listado de forma autom√°tica. 
 
![Image 3](/assets/img/posts/xenomorph-2022/Imagen 3.png)