---
layout: post
title: üá™üá∏ Analysis of the trojan Emotet
author: voidm4p
date: 2019-11-16 09:00:00
toc: true
categories:
- malware
tags:
- emotet
- windows
---
# An√°lisis del troyano Emotet 
 
Tras un periodo de descanso, los actores que operan la botnet (t√©rmino que hace referencia a un conjunto o red de robots inform√°ticos o bots , que se ejecutan de manera aut√≥noma y autom√°tica) de **Emotet** decidieron volver a la carga con m√°s actividad que nunca y con campa√±as, principalmente de malspam (emails maliciosos), con bastante foco en entidades espa√±olas. 
 
La finalidad de esta investigaci√≥n es aportar datos t√©cnicos objetivos sobre el c√≥digo da√±ino y las campa√±as, puesto que, dado su impacto y repercusi√≥n, no todas las noticias y art√≠culos que aparecen al respecto son siempre del todo exactos y pueden conducir a malentendidos. 

## Historia 
Emotet, que lleva activo aunque con ciertas interrupciones desde 2014, se cree que se trata de la evoluci√≥n de un troyano llamado **Feodo**, aka **Brugat/Cridex**, que apareci√≥ en 2010 y, los actores que controlan la botnet, han recibido diferentes nombres por parte de los investigadores y compa√±√≠as de seguridad inform√°tica, entre ellos, <a href="https://www.proofpoint.com/us/threat-insight/post/threat-actor-profile-ta542-banker-malware-distribution-service" target="_blank">**TA542**</a>, <a href="https://www.symantec.com/blogs/threat-intelligence/evolution-emotet-trojan-distributor" target="_blank">**Mealybug**</a> y <a href="https://www.crowdstrike.com/blog/meet-crowdstrikes-adversary-of-the-month-for-february-mummy-spider/" target="_blank">**MUMMY SPIDER**</a>. 
 
Emotet se trata de un **c√≥digo da√±ino modular** cuya principal acci√≥n inicial es conectarse con sus servidores de mando y control (C2) para, de aqu√≠, recibir los m√≥dulos a ejecutar en el equipo de la v√≠ctima.  
 
Entre 2014 y principios de 2017, Emotet, tambi√©n llamado **Geodo**, pod√≠a ser considerado como un troyano bancario, puesto que inclu√≠a un m√≥dulo para realizar dichas acciones mediante inyecciones en el navegador de la m√°quina infectada.  
 
Sin embargo, desde entonces, su principal funci√≥n es la de actuar como cargador de otras familias de c√≥digos da√±inos, lo que se conoce como un "*Downloader*" y siendo renombrado como **Heodo** por parte de <a href="https://feodotracker.abuse.ch/browser" target="_blank">los investigadores</a>. Esto sugiere un cambio en el modelo de negocio de Emotet a partir de esa fecha, siendo la principal fuente de ingresos, la venta del acceso a su botnet a otros cibercriminales (*Pay-Per-Install*, PPI ), en lugar de monetizar directamente la informaci√≥n financiera robada con su m√≥dulo bancario. Adem√°s, el propio troyano tambi√©n puede descargar otros m√≥dulos, como herramientas *freeware* para recolecci√≥n de credenciales almacenadas en los navegadores y clientes de mail de la v√≠ctima, as√≠ como otro para realizar SPAM de correos a los contactos de la v√≠ctima y, as√≠ propagarse a s√≠ mismo.  

## An√°lisis Campa√±a Malspam 
A continuaci√≥n se muestra el an√°lisis completo de una campa√±a de correos malicioso. El email ten√≠a el siguiente aspecto al abrirlo en Microsoft Outlook: 

![Image 1](/assets/img/posts/emotet-2019/img02_01.png)

Como se puede observar, el texto est√° escrito en castellano, al igual que el nombre del fichero adjunto. Si se expande el men√∫ de opciones, haciendo click en la flecha de la derecha del fichero, se puede guardar en disco para su an√°lisis. 
 
Las funciones resumen (hash) que identifican al fichero son: 
 
- **MD5**: defdfdfe9fb91a08d1e2abe4ded5f89f 
- **SHA-1**: a085a7bec18f18627486540a7eb3af9828981738 
- **SHA-256**: 005e2b2c2d664b9300ab2efb470dbb1a54e7be009a044886ac811e606c2f8b62 
 
La extensi√≥n que utiliza el fichero adjunto es .doc y, se puede comprobar que, efectivamente, se trata de un documento ofim√°tico mediante el comando `file`: 
 
```
$ file Archivo_092019\ 2846564.doc 
Archivo_092019 2846564.doc: Composite Document File V2 Document, Little Endian, Os: Windows, Version 6.1, Code page: 1252, Title: West Virginia solid state, Subject: bandwidth, Author: Buford Dickinson, Comments: Licensed real -time e -enable, Template: Norm al.dotm, Revision Number: 1, Name of Creating Application: Microsoft Office Word, Create Time/Date: Wed Sep 18 15:38:00 2019, Last Saved Time/Date: Wed Sep 18 15:38:00 2019, Number of Pages: 1, Number of Words: 95, Number of Characters: 547, Security: 0 
```

Adem√°s, se observa que se han introducido metadatos como el t√≠tulo, asunto, autor o comentarios para darle mayor credibilidad. 
 
El fichero se subi√≥ por primera vez a la plataforma VirusTotal  con fecha 18 de septiembre, siendo detectado como malicioso entonces, por 16/59 motores antivirus.

![Image 2](/assets/img/posts/emotet-2019/img03_02.png)
 
Se puede comprobar que el documento contiene macros Visual Basic for Application (**VBA**) mediante la utilidad `olevba` de *oletools*.

![Image 3](/assets/img/posts/emotet-2019/img04_03.png)
 
El documento, una vez abierto, muestra el siguiente mensaje, donde incita al usuario a que active el uso de macros: 
 
![Image 4](/assets/img/posts/emotet-2019/img04_04.png)

Tras activar las macros, √©stas terminan ejecutando un nuevo proceso *powershell.exe* mediante WMI al cual le pasa un comando codificado en base64: 
 
![Image 5](/assets/img/posts/emotet-2019/img05_05.png)
 
Tras decodificarlo y formatearlo para que sea m√°s legible, se puede ver c√≥mo, lo que har√° es intentar descargar un fichero de diferentes URLs que tiene configuradas, hasta que alguna responda y, guardarlo en la carpeta %USERPROFILE% con el nombre 835.exe para ejecutarlo desde ah√≠.  
 
![Image 6](/assets/img/posts/emotet-2019/img05_06.png)

La variable `$dj6dmr` forma un array con todas las direcciones, tras separarlas por el car√°cter ‚Äú@‚Äù. Con la herramienta <a href="https://ciberseguridad.blog/analizando-malware-que-utilice-visual-basic-script-javascript-y-o-powershell/" target="_blank">vbjsexec.exe</a> se pueden ejecutar directamente comandos powershell y ver su salida. 
 
![Image 7](/assets/img/posts/emotet-2019/img06_07.png)

- <span style="color:red">hxxp://thinhvuongmedia[.]com/wp-admin/n2keep7/</span>
- hxxps://mnpasalubong[.]com/wp-admin/nsmz9az032/ 
- hxxp://trunganh[.]xyz/wp-content/uzq50/ 
- <span style="color:red">hxxps://iptivicini[.]com/npkx/jwpy938/</span>
- hxxps://www[.]cezaevinegonder[.]com/conf/fd45/ 

En el momento del an√°lisis, las √∫nicas URLs que responden descargando un fichero son las marcadas en rojo. 
 
Comprobando la segunda de ellas, se ha encontrado un fichero "index.php.suspected" que, podr√≠a ser el script que descargaba el fichero, pero que ha sido renombrado para que ya no lo haga y, por tanto, es tambi√©n posible descargarlo para inspeccionar el c√≥digo PHP. 

![Image 8](/assets/img/posts/emotet-2019/img07_08.png)
![Image 9](/assets/img/posts/emotet-2019/img08_09.png)
 
Como se puede apreciar, el binario se encuentra embebido en el c√≥digo, en formato base64 y comprimido por lo que, para servirlo, utiliza las funciones de PHP `gzinflate` y `base64_decode`. 

## An√°lisis del binario - Empaquetado 
El fichero descargado se identifica por los siguientes hashes: 
 
- **MD5**: d6292a033cb1bd643a7a380efef6d015 
- **SHA-1**: 15c7d543c4103a5d505d19313b8a199b14310c0f 
- **SHA-256**: 444d296659bea1ca6c115b455a27adae6537958f9f8e30e63d3b1a8a720c5cb7 
 
El binario simula ser un ejecutable leg√≠timo de Microsoft mediante su descripci√≥n: 

![Image 10](/assets/img/posts/emotet-2019/img09_10.png)

Como puede observarse, el binario est√° compilado con Microsoft Visual C++. Para poder analizar correctamente la muestra, primero hay que comprobar si el c√≥digo se encuentra empaquetado, pues el que interesa analizar es el c√≥digo real del troyano que se encuentra en su interior. Para ello, en primer lugar, se comprueba si las herramientas Detect It Easy o RDG Packer Detector detectan alg√∫n empaquetador comercial o conocido: 
 
![Image 11](/assets/img/posts/emotet-2019/img10_11.jpg)
 
Ninguna de las dos herramientas detectan el uso de packers comerciales, por lo que, de estar empaquetada, se debe de tratar de un empaquetador propio no conocido. 
 
Existen otras formas de comprobar si una muestra est√° empaquetada, como puede ser comprobar su entrop√≠a, buscar en sus cadenas de texto, comprobar las funciones que importa, etc. En este caso, se ejecuta directamente la muestra y se observa su comportamiento desde un explorador de procesos, como Process Explorer. De esta ejecuci√≥n, se observa que la muestra se relanza a s√≠ misma con un par√°metro y, despu√©s, se copia y vuelve a lanzar desde otro directorio. 
 
Puesto que crea un par de procesos hijos, se puede establecer un punto de interrupci√≥n con un debugger en la API `CreateProcessInternalW`, que es una de las APIs a bajo nivel que se encarga de la creaci√≥n de nuevos procesos para, a partir de ese punto, intentar encontrar en la memoria del proceso si se ha extra√≠do o desempaquetado alg√∫n binario. 

Para ello, se carga la muestra en x32dbg (la versi√≥n de 32 bits de x64dbg) y, en la secci√≥n de "S√≠mbolos", se busca la API `CreateProcessInternalW` dentro de *kernel32*.dll y se establece un punto de interrupci√≥n en ella (tecla F2). 
 
![Image 12](/assets/img/posts/emotet-2019/img11_12.png)
 
Ejecutando la muestra (tecla F9), se llega al punto de entrada del programa y, volviendo a ejecutar, se alcanza el punto de interrupci√≥n establecido. En dicho momento, se observan dos secciones de memoria fuera del espacio del propio binario que poseen per misos de ejecuci√≥n: 
 
![Image 13](/assets/img/posts/emotet-2019/img11_13.png)

En la primera de ellas, puede observarse una cabecera PE, por lo que se extrae a disco para su an√°lisis (bot√≥n derecho sobre la secci√≥n de memoria). 
 
![Image 14](/assets/img/posts/emotet-2019/img11_14.png)
 
Mediante la herramienta XVI32 se localiza el punto donde empieza dicha cabecera dentro del volcado de memoria y se elimina todo el contenido hasta dicho punto. 

![Image 15](/assets/img/posts/emotet-2019/img12_15.png)
 
Se realiza el mismo proceso con PE-Bear, para eliminar el sobrante del volcado por la parte inferior. (Nota: realizando este proceso, PE-Bear cambia un byte de la cabecera PE que hay que volver a restaurar a su valor anterior para que el binario siga siendo funcional). 

![Image 16](/assets/img/posts/emotet-2019/img13_16.png)
 
## An√°lisis del binario - Desempaquetado 
El binario extra√≠do ocupa √∫nicamente 64KB:  

![Image 17](/assets/img/posts/emotet-2019/img13_17.png)

Es identificado por los siguientes hashes: 
 
- **MD5**: 147b711df549b8d99401bd49162c55ca 
- **SHA-1**: 269ce525873ac5e43e6a7002b122a386858aab5e 
- **SHA-256**: 26a494937d54c25f6e384bf77b04e8ea2ef17ee9aca971de8188af371e934367 
 
Se subi√≥ a la plataforma VirusTotal por primera vez el d√≠a 21 de septiembre de 2019 con el nombre "emotet_unpacked.exe" y, siendo detectado en ese momento, por 36/70 motores antivirus.

![Image 18](/assets/img/posts/emotet-2019/img14_18.png)

Emotet √∫nicamente importa una funci√≥n externa mediante su tabla de importaciones por lo que, seguramente haga uso de la API LoadLibrary para resolver las APIs que vaya a utilizar en tiempo de ejecuci√≥n: 

![Image 19](/assets/img/posts/emotet-2019/img14_19.png) 

El pseudoc√≥digo decompilado del binario por IDA Pro tiene el siguiente aspecto: 

![Image 20](/assets/img/posts/emotet-2019/img15_20.png) 

Para darle sentido a cada una de las funciones, se procede a debuguear la aplicaci√≥n funci√≥n por funci√≥n y as√≠ renombrar cada una de las funciones con un nombre m√°s descriptivo y que permita entender el flujo de ejecuci√≥n completo. 
 
![Image 21](/assets/img/posts/emotet-2019/img16_21.png) 

Las dos primeras funciones cargan din√°micamente las APIs de las librer√≠as *ntdll.dll* y *kernel32.dll* mediante la t√©cnica "*Call API by hash*". El manejador de estas dos librer√≠as es obtenido enumerando el PEB, mientras que para el resto de librer√≠as que se ver√° m√°s adelante, utiliza la API `LoadLibrary`. El binario almacena una serie de hashes de funciones que le interesa importar, los compara con el resultado de realizar ese hash sobre los nombres de las funciones exportadas de las librer√≠as y se encarga de reso lverlos. No obstante, no todos los hashes almacenados corresponden a nombres de funciones y seguramente hayan sido introducidos para confundir al analista. 
 
![Image 22](/assets/img/posts/emotet-2019/img16_22.png)

Tras resolver estas funciones, llama a la API `GetModuleFileNameW` para obtener la ruta completa de ejecuci√≥n del binario. A continuaci√≥n, llama a una funci√≥n que calcula un valor hexadecimal en base a dicha ruta mediante el siguiente algoritmo: 

```python
def emotet_calc_param(path): 
    value = 0 
    index = 0 
    for c in path: 
        value = (value * 0x1003f) & 0xffffffff 
        value += (ord(c) & 0xff) 
        index+=1 
    return value 
```

Todas las cadenas de caracteres que utiliza el binario est√°n cifradas y, utiliza una funci√≥n propia para descifrarlas. La funci√≥n necesita dos par√°metros, el primero es la cadena cifrada, donde su primer DWORD es utilizado para calcular el tama√±o de la cadena y, el segundo, la clave XOR. El siguiente c√≥digo Python implementa el algoritmo utilizado: 

```python
import struct 
def emotet_decrypt_string(ciphertext, key): 
    ciphertext_size = struct.unpack('<I', ciphertext[:4].encode('latin1'))[0] 
    ciphertext_data = ciphertext[4:] 
    real_size = ciphertext_size ^ key 
    i = 0 
    result = '' 
    while i < real_size: 
        result += struct.pack("<I", struct.unpack('<I', ciphertext_data[i:i+4].encode('latin1'))[0] ^ key).decode('latin1') 
        i += 4 
    return result[:real_size] 
```

En este caso, recupera la cadena "--%x", la cual formatea con el valor hexadecimal calculado para comprobar, mediante la llamada a `GetCommandLineW` si se le ha pasado ese par√°metro al binario. En caso de no haberlo hecho, llama a una funci√≥n que se encarga de lanzar el proceso de nuevo con ese par√°metro mediante `CreateProcessW` y termina el actual con `ExitProcess`. 
 
Si el programa ha sido iniciado con el par√°metro correspondiente contin√∫a la ejecuci√≥n con la siguiente rutina: 

![Image 23](/assets/img/posts/emotet-2019/img18_23.png) 

El programa posee una serie de variables globales que utiliza a lo largo de la ejecuci√≥n. En primer lugar, recupera el valor del n√∫mero de serie del disco duro donde se encuentra instalado Windows (HWID), mediante las llamadas a las APIs `GetWindowsDirectory` y `GetVolumeInformation`. 

![Image 24](/assets/img/posts/emotet-2019/img18_24.png) 

A continuaci√≥n, con este valor pasa a una rutina donde comprobar√° la existencia de dos mutex y un evento. 

![Image 25](/assets/img/posts/emotet-2019/img19_25.png) 
 
En primer lugar, llama a la API `CreateMutex` con una cadena que, mediante el siguiente formato rellena con el valor del HWID: ‚ÄúGlobal\\I%X‚Äù. 
 
![Image 26](/assets/img/posts/emotet-2019/img19_26.png) 
 
Si √©ste no existe, contin√∫a creando otro mutex con el formato ‚ÄúGlobal\\M%X‚Äù 
 
![Image 27](/assets/img/posts/emotet-2019/img19_27.png) 

Y termina creando un evento con el formato ‚ÄúGlobal\\E%X‚Äù. 

![Image 28](/assets/img/posts/emotet-2019/img20_28.png) 
 
Tras esto, contin√∫a la ejecuci√≥n con una nueva rutina dividida en 3 pasos para instalarse, inicializar variables criptogr√°ficas y continuar. 
 
Para el proceso de instalaci√≥n, en primer lugar, resuelve las APIs de las DLL *advapi32.dll* y *shell32.dll*.

![Image 29](/assets/img/posts/emotet-2019/img20_29.png) 

Tras esto, mediante una nueva funci√≥n, inicia el proceso de instalaci√≥n. 

![Image 30](/assets/img/posts/emotet-2019/img20_30.png) 

En primer lugar, comprueba los permisos con los que se ejecuta el binario mediante la API `OpenSCManager`, guardando el resultado en una variable global. 

![Image 31](/assets/img/posts/emotet-2019/img21_31.png)  
 
Tambi√©n obtiene el nombre del propio binario. 

![Image 32](/assets/img/posts/emotet-2019/img21_32.png)
 
Para generar un nuevo nombre para el ejecutable, se descifra una cadena de palabras 
separadas por comas. 

```
chunk,counter,drawa,isve,two,next,mapi,rtapi,nlsdl,defs,tenant,rstrt,window,machine,mira,system,stream,cursor,structs,history,watched,hash,report,program,durable,offc,rsat,folders,shell,yellow,sounds,adjust,toner,tlb,sorted,loop,post,txt,icons,intel,inset,move,reports,trc,based,wim,lumber,violet,dom,easy,cvt,center,even,readand,xinput,mem,cues,layer,tools,wfd,running,mail,gesture,misc 
```

![Image 33](/assets/img/posts/emotet-2019/img21_33.png) 
 
Mediante una funci√≥n que hace uso de esta lista y del HWID, se calcula el nombre del binario. 

![Image 34](/assets/img/posts/emotet-2019/img22_34.png) 

El siguiente c√≥digo python 3 resume el algoritmo utilizado: 
 
```python
def emotet_calculate_new_name(wordlist, hwid): 
    index = 2 
    new_hwid = hwid 
    result = '' 
    while index != 0: 
        i_remainder = new_hwid % len(wordlist) 
        new_hwid = ~int(new_hwid / len(wordlist)) & 0xFFFFFFFF 
        result += wordlist[wordlist.rfind(',', 0, i_remainder)+1:].split(',')[0] 
        index -= 1 
    return result 
```

En funci√≥n de los permisos comprobados anteriormente, la ruta de instalaci√≥n es 
‚ÄúC:\Windows\System32‚Äù (32 -bit) /  ‚ÄúC: \Windows\SysWOW64‚Äù (64 -bit) √≥ ‚Äú%localappdata%‚Äù. Para ello, utiliza la API `SHGetFolderPath`, pas√°ndole las constantes `CSIDL_SYSTEMX86` y `CSIDL_LOCAL_APPDATA`. 

![Image 35](/assets/img/posts/emotet-2019/img22_35.png) 


En este proceso calcula el hash CRC32 del binario para utilizarlo m√°s adelante mediante la `API RtlComputeCrc32`. 
 
![Image 36](/assets/img/posts/emotet-2019/img23_36.png) 

 
Y tambi√©n establece el botID basado en el nombre del equipo, que obtiene mediante 
`GetComputerName` y el HWID previo, con el formato "nombreequipo_HWID". 

![Image 37](/assets/img/posts/emotet-2019/img23_37.png) 

Posteriormente intenta borrar un fichero con extensi√≥n .exe de la ruta de instalaci√≥n, posiblemente versiones anteriores. Para ello, utiliza una nueva lista. 

```
bml,vault,apo,ttls,winsat,cim,types,depth,idaho,example,photos,gateway,themes,khmer,lite,rpl,media,tran,mondeu,plan,power,sans,subs,namesof,sine,events,enums,tier,icon,nirmala,cred,was,ipsm,sms,flows,code,sound,dlls,click,lanes,vmbus,blb,setthe,tasks,item,als,cluster,prof,psec,cofire,ram,phong,vector,notices,cull,netsh,wan,cpl,shims,convert,chx,sens,ihun,priv 
```

![Image 38](/assets/img/posts/emotet-2019/img24_38.png) 

 
A continuaci√≥n copia el fichero al directorio correspondiente y elimina el Zone.Identifier para que no se sepa que ha sido descargado de internet. 

![Image 39](/assets/img/posts/emotet-2019/img24_39.png) 

Por √∫ltimo, crea un servicio para lanzar el binario copiado, en caso de tener permisos mediante `CreateService` y `ChangeServiceConfig2W`. 

![Image 40](/assets/img/posts/emotet-2019/img25_40.png) 

O s√≠mplemente lo lanza mediante `CreateProcess` en caso contrario. Una vez instalado, se repite todo el flujo descrito y, llega al paso 2 del men√∫ previo, donde procede a inicializar variables criptogr√°ficas. 

![Image 41](/assets/img/posts/emotet-2019/img25_41.png) 
 
En primer lugar, carga las librer√≠as *crypt32.dll*, *urlmon.dll*, *userenv.dll*, *wininet.dll* y *wtsapi32.dll*. Tras esto, obtiene la lista de servidores de mando y control que se encuentra cifrada dentro del binario. 

![Image 42](/assets/img/posts/emotet-2019/img26_42.png) 

 
En dicha funci√≥n tambi√©n utiliza la API `CryptImportKey` para importar una clave RSA p√∫blica que tambi√©n se encuentra dentro del binario. 
 
![Image 43](/assets/img/posts/emotet-2019/img26_43.png) 

Tras esto, pasa a la rutina principal del c√≥digo da√±ino donde recopila informaci√≥n sobre el sistema infectado y contacta con los servidores de mando y control. Aqu√≠, va creando una estructura que empieza por 0x00 donde va concatenando la versi√≥n del sistema obtenida con `RtlGetVersion` y `GetNativeSystemInfo`, el SessionId del PEB (que se encuentra en el offset 0x1d4), el hash crc32 del binario calculado anteriormente, la lista de procesos en ejecuci√≥n mediante `CreateToolhelp32Snapshot` separada por comas. 
 
![Image 44](/assets/img/posts/emotet-2019/img27_44.png) 

Esta estructura es tratada por una funci√≥n que prepara el paquete a enviar al servidor de mando y control. Emotet utiliza una implementaci√≥n basada en Google Protocol Buffers con la siguiente estructura. 

```c
syntax = "proto2"; 
 
message RegistrationRequestBody { 
    required int32 counter = 1; 
    required string botId = 2; 
    required int32 osVersion = 3; 
    required int32 sessionId = 4; 
    required fixed32 crc32 = 5; 
    required string proccessList = 6; 
    required string pluginsInstalled = 7; 
} 
```

Para codificar esta estructura, Emotet identifica a cada tipo de campo del mensaje con un enumerado que puede tomar los valores 0, 1, 2 o 5. 
 
- Tipo 0: int32. Se codifica como <a href="https://github.com/fmoo/python-varint/blob/master/varint.py" target="_blank">varint</a> bytes. 

```python
def encode(number): 
    buf = b'' 
    while True: 
        towrite = number & 0x7f 
        number >>= 7 
        if number: 
            buf += bytes((towrite | 0x80,)) 
        else: 
            buf += bytes((towrite,)) 
            break 
    return buf 
```
- Tipo 2: string . Se codifica a√±adiendo la longitud de la cadena y, a continuaci√≥n la cadena. 
- Tipo 5: fixed32. No se codifica. 
- Tipo 1: es un valor considerado dentro de los posibles que acepta la funci√≥n de codificaci√≥n, pero nunca es llamada con √©l, por lo que no se utiliza. 
 
En base al tipo y el id del campo, calcula un magic byte para identificar cada campo mediante la siguiente f√≥rmula: `((8*proto_buf_id) | tipo)`. Por tanto, para los campos indicados, 
los identificadores ser√≠an: 
 
- (0x1 * 0x8) \| 0x0 = <span style="color:red">0x8</span> 
- (0x3 * 0x8) \| 0x0 = <span style="color:red">0x18</span>   
- (0x4 * 0x8) \| 0x0 = <span style="color:red">0x20</span>  
- (0x5 * 0x8) \| 0x5 = <span style="color:red">0x2D</span>  
- (0x6 * 0x8) \| 0x2 = <span style="color:red">0x32</span>  
- (0x7 * 0x8) \| 0x2 = <span style="color:red">0x3A</span>  
 
A continuaci√≥n puede observarse la estructura completa, una vez rellenada por la funci√≥n.

![Image 45](/assets/img/posts/emotet-2019/img29_45.png) 

Este paquete es, a su vez, encapsulado dentro de otra estructura, en la que se le indica un comando que, para la petici√≥n inicial, se encuentra establecido a 16 y, a continuaci√≥n, el contenido del paquete anterior. 

```c
message RegistrationRequest 
{ 
    required int32 command = 1 [default = 16]; 
    optional bytes data = 2; 
} 
```

Este nuevo paquete es comprimido mediante *zlib* y cifrado con la clave AES generada. Tras esto, se crea una nueva estructura, que concatena, la clave AES, cifrada mediante la API `CryptExportKe`y` con la clave RSA, el hash SHA1 del contenido de data antes de ser cifrado y, el paquete cifrado. 
 
![Image 46](/assets/img/posts/emotet-2019/img29_46.png) 

 
El siguiente c√≥digo python resume el proceso de cifrado del paquete: 

```python
def emotet_encrypt(self, data): 
    #Export session key 
    rsa = PKCS1_OAEP.new(self.rsaKey) 
    session = rsa.encrypt(self.aesKey) 

    #SHA1 hash data 
    h = SHA.new() 
    h.update(data) 
    sha = h.digest() 
    #AES encrypt data 
    cipher = AES.new(self.aesKey, AES.MODE_CBC, '\x00' * 16) 
    data = pad(data) 
    enc = cipher.encrypt(data) 
    return session + sha + enc 
```
 
Finalmente, el mensaje es enviado al servidor de mando y control mediante una petici√≥n de tipo POST. Para ello, a√±ade una cabecera con el *User-Agent* siguiente: 

```
Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) 
```

Adem√°s, a√±ade la cabecera *Referer* con la direcci√≥n y ruta a la que se hace la petici√≥n, la cabecera *DNT* con el valor 1 y se utiliza el formato "application/x -www-form-urlencoded" con un par√°metro que es una cadena aleatoria y, el paquete anterior, codificado en base64 y urlencoded. 
 
![Image 47](/assets/img/posts/emotet-2019/img30_47.png) 

Emotet contiene un listado de palabras que utiliza para generar una serie de rutas a las que realizar la petici√≥n, aunque este no es relevante y es √∫nicamente utilizado como m√©todo de dificultar el perfilado y detecci√≥n del paquete de red. 
 
Si la informaci√≥n enviada est√° dentro de lo que espera el servidor de mando y control, pero no se est√° ejecutando la √∫ltima versi√≥n del c√≥digo da√±ino, que es identificada por su CRC32, usualmente responde con un fichero binario que se trata de la √∫ltima ve rsi√≥n. Si es esta la que est√° siendo ejecutada, se habr√° enviado su CRC32 y, si coincide con la √∫ltima, el servidor de mando y control responder√° con los m√≥dulos a ejecutar. 
 
Puede darse el caso de que la respuesta no sea esta, por lo que hay que tener ciertas consideraciones en mente: 
 
- **Pa√≠s**: dependiendo del pa√≠s de la direcci√≥n IP desde donde se realiza la petici√≥n la respuesta del servidor puede variar. Si el pa√≠s desde donde se conecta no est√° entre los objetivos de Emotet, no responde ning√∫n m√≥dulo. Si el pa√≠s desde el que se conecta recibe los m√≥dulos pero no otro c√≥digo da√±ino, puede ser que el pa√≠s est√© en la lista de objetivos pero no haya una campa√±a activa en ese momento para distribuir c√≥digo da√±ino en ese pa√≠s. Si, por el contrario, se reciben ambas cosas, se puede asegurar que el pa√≠s est√° entre la lista de objetivos de la botnet. 
- **ID del bot**: cuando se realiza una petici√≥n a la botnet, se especifica un ID de bot para ser identificado de forma √∫nica en la botnet. Una vez registrado un bot, siempre recibir√° la misma respuesta que recibi√≥ en primer lugar, aunque cambie el pa√≠s desde el que se conecte o cualquier otra informaci√≥n enviada. 
- **Hora y d√≠a**: en ciertas ocasiones, sobre todo durante los fines de semana, la botnet parece no responder sin importar cualquiera de los otros dos casos. 
 
Una vez establecido el valor CRC32 correcto, el servidor manda una respuesta con la misma estructura que la petici√≥n enviada, donde se incluye la clave de sesi√≥n, el hash del contenido para verificar su integridad una vez descifrado y, un mensaje cifrado con la clave AES que se envi√≥ previamente y comprimido con ZLIB. Tras descifrarlo y descomprimirlo, para manejar estas posibles respuestas, Emotet utiliza los siguientes mensajes: 

```c
message RegistrationResponse  
{ 
    required int32 type = 1; 
    optional bytes updatedBin = 2; 
    optional bytes deliverable = 3; 
} 
 
message Module 
{ 
    required int32 modId = 1; 
    required int32 executeFlag = 2; 
    required bytes blob = 3; 
} 
```

De esta forma, recibe un listado de m√≥dulos, donde cada uno cuenta con un ID del m√≥dulo, un flag para indicar de qu√© forma se debe ejecutar y, el propio binario. 
 
En funci√≥n del flag utilizado (1, 2 o 3), realiza la ejecuci√≥n de diferentes formas. Si el par√°metro especificado es 1 o 2, el m√≥dulo es un binario ejecutable y se escribe en disco en la carpeta %PROGRAMDATA%, la diferencia reside en c√≥mo es ejecutado. El par√°metro 3 es utilizado para los m√≥dulos que son DLL. 
 
- El flag 1, ejecuta el binario mediante `CreateProcess`.

![Image 48](/assets/img/posts/emotet-2019/img32_48.png)

- El flag 2 ejecuta el binario con `CreateProcessAsUser`, despu√©s de haber obtenido el token del usuario mediante `WTSGetActiveConsoleSessionId`, `WTSQueryUserToken` y `DuplicateToken`. 
 
![Image 49](/assets/img/posts/emotet-2019/img32_49.png)
 
- El flag 3 indica que el m√≥dulo se cargue directamente en la memoria del proceso de 
Emotet para lo cual hace uso de la API `CreateThread`.

![Image 50](/assets/img/posts/emotet-2019/img33_50.png)

 
Esta √∫ltima opci√≥n, llama a la funci√≥n exportada `DllEntryPoint`, pas√°ndole como segundo par√°metro un 10 y como tercero, el ID del bot. 

![Image 51](/assets/img/posts/emotet-2019/img33_51.png)

De esta forma, los m√≥dulos √∫nicamente llevan a cabo su funcionalidad si reciben ese par√°metro. 

![Image 52](/assets/img/posts/emotet-2019/img33_52.png)

 
Durante el an√°lisis realizado, se ha observado la descarga de m√≥dulos con los siguientes ID: 458, 459, 461, 463, 663, 664, 1146, 1687, 1688, 2000, 2001, 1517 y 1621. Todos salvo los dos √∫ltimos son DLL y utilizan el flag 3 para inyectarse directamente en memoria sin almacenarse en el disco duro. Los otros dos son binarios ejecutables y reciben el par√°metro 2.

## An√°lisis de los m√≥dulos de Emotet 
Los m√≥dulos propios de Emotet son DLL y su estructura parece ser bastante similar.  
 
![Image 53](/assets/img/posts/emotet-2019/img34_53.png)

Adem√°s, algunos de ellos incluyen una rutina de descifrado basada en XOR que extrae un binario a la memoria.
 
- M√ìDULO 458 - MailPassView 
- M√ìDULO 459 - Port Forwarding (uPnP) 
- M√ìDULO 461 - Extractor de contactos de email  
- M√ìDULO 463 - Web Browser Pass View 
- M√ìDULO 663 - Movimiento Lateral (listado usuarios) 
- M√ìDULO 664 - Movimiento Lateral (listado de contrase√±as) 
- M√ìDULO 1146 - Extracci√≥n de Emails 
- M√ìDULOS 1187 Y 2000 - SPAM 
- M√ìDULOS 1188 y 2001 - SPAM 
 

## Cape Sandbox & IOCs
CAPE se trata de una versi√≥n modificada de Cuckoo Sandbox y posee la capacidad de detectar y extraer la configuraci√≥n de las familias de malware m√°s relevantes. La muestra es detectada como Emotet y en la secci√≥n CAPE se observa la configuraci√≥n extra√≠da mediante un script que puede consultarse en <a href="https://github.com/ctxis/CAPE/blob/92751675c01c0909c0a82922b12621801f04789c/modules/processing/parsers/mwcp/parsers/Emotet.py" target="blank">su repositorio</a>. 


Clave p√∫blica RSA:
```
-----BEGIN PUBLIC KEY----- 
MHwwDQYJKoZIhvcNAQEBBQADawAwaAJhAOzoTryw1r9RxRJPFKalO4+q7JaDZWSB 
KZlEc22H6ITuE06tvJspue42TF1yk8xN+1bqW++QeV6Clm1uRswA/qoao/6p4eN0 
h4zIO8PEaJ0C/9EO4cx9yfRLlVpjdEkP0QIDAQAB 
-----END PUBLIC KEY----- 
````

C2:
```
190[.]117[.]206[.]153:443 
179[.]62[.]18[.]56:443 
123[.]168[.]4[.]66:22 
178[.]249[.]187[.]151:8080 
217[.]199[.]160[.]224:8080 
62[.]75[.]150[.]240:7080 
71[.]244[.]60[.]230:7080 
119[.]59[.]124[.]163:8080 
211[.]229[.]116[.]97:80 
190[.]38[.]14[.]52:80 
217[.]113[.]27[.]158:443 
203[.]25[.]159[.]3:8080 
190[.]19[.]42[.]131:80 
187[.]188[.]166[.]192:80 
51[.]15[.]8[.]192:8080 
23[.]92[.]22[.]225:7080 
189[.]166[.]68[.]89:443 
88[.]250[.]223[.]190:8080 
189[.]129[.]4[.]186:80 
86[.]42[.]166[.]147:80 
46[.]163[.]144[.]228:80 
109[.]104[.]79[.]48:8080 
181[.]81[.]143[.]108:80 
183[.]82[.]97[.]25:80 
190[.]230[.]60[.]129:80 
81[.]169[.]140[.]14:443 
79[.]143[.]182[.]254:8080 
109[.]169[.]86[.]13:8080 
187[.]155[.]233[.]46:443 
87[.]106[.]77[.]40:7080 
62[.]75[.]160[.]178:8080 
149[.]62[.]173[.]247:8080 
190[.]1[.]37[.]125:443 
190[.]221[.]50[.]210:8080 
217[.]199[.]175[.]216:8080 
46[.]28[.]111[.]142:7080 
5[.]196[.]35[.]138:7080 
46[.]21[.]105[.]59:8080 
200[.]57[.]102[.]71:8443 
151[.]80[.]142[.]33:80 
138[.]68[.]106[.]4:7080 
119[.]92[.]51[.]40:8080 
89[.]188[.]124[.]145:443 
178[.]79[.]163[.]131:8080 
200[.]21[.]90[.]6:8080 
114[.]79[.]134[.]129:443 
190[.]200[.]64[.]180:7080 
190[.]104[.]253[.]234:990 
71[.]244[.]60[.]231:7080 
91[.]205[.]215[.]57:7080 
189[.]187[.]141[.]15:50000 
91[.]83[.]93[.]124:7080 
46[.]29[.]183[.]211:8080 
183[.]87[.]87[.]73:80 
212[.]71[.]237[.]140:8080 
62[.]75[.]143[.]100:7080 
185[.]86[.]148[.]222:8080 
77[.]245[.]101[.]134:8080 
79[.]127[.]57[.]42:80 
159[.]203[.]204[.]126:8080 
201[.]184[.]65[.]229:80 
181[.]188[.]149[.]134:80 
181[.]36[.]42[.]205:443 
80[.]85[.]87[.]122:8080 
77[.]55[.]211[.]77:8080 
186[.]83[.]133[.]253:8080 
50[.]28[.]51[.]143:8080 
200[.]58[.]171[.]51:80 
46[.]41[.]151[.]103:8080 
201[.]163[.]74[.]202:443 
5[.]77[.]13[.]70:80 
```